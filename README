toiletline
----------------
Single-file framework library for raw terminal applications,
meant to replace a small subset of GNU Readline, and work on both Linux and Windows.

It behaves like a regular shell, with all features implemented from scratch in raw mode.

Any help finding bugs is appreciated.

Current features
----------------
* UTF-8 support.
* In-memory history.
* CTRL to move/erase a word.
* End/Home to jump to end/beginning.

Documentation
----------------
Before you include this file in C or C++ file,
define "TOILETLINE_IMPLEMENTATION" to create the implementation.

int tl_init(void);
--------
Initialize toiletline and put terminal into raw mode.
Returns 1 on success.

int tl_readline(char *line_buffer, size_t size, const char *prompt);
--------
Read a line while in toiletline mode.

To support multi-byte characters and null at the end, size needs to be at least 2 or more.
Submitted input will be written to *line_buffer as a null-terminated string.

Beware of characters like '\t' (Tab) and such, as they may break cursor position.
Althrough they are considered as a single character, they occupy more than one space.

Returns:
* -1 on internal error;
* 0 on Enter;
* 1 on Ctrl-C;
* 2 when line read exceeded *line_buffer size.

int tl_getc(char *char_buffer, size_t size, const char *prompt);
--------
Read a character without waiting for Enter.
Return values are the same as of tl_readline.

int tl_exit(void);
--------
Exit and deallocate memory.
Returns 1 on success.

size_t tl_utf8_strlen(const char *utf8_str);
--------
Get the amount of characters in a UTF-8 string:

Since number of bytes can be bigger than amount of characters,
regular strlen will not work, and will only return the number of bytes before \0.

Examples
----------------
For an example program, take a look at example.c
