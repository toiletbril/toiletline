toiletline
----------------
Single-file framework library for raw terminal applications,
meant to replace a small subset of GNU Readline, and work on both Linux and Windows.

It behaves like a regular shell, while the terminal is in raw mode,
with all features implemented from scratch.

Accepts UTF-8 characters. For very specific cases, parsed UTF-8 may not be valid.

Any help finding bugs is appreciated.

Current features
----------------
* Up/Down to navigate history.
* Right/Left, to move one character, with to Ctrl move a word.
* End/Home to jump to end/beginning.
* Backspace/Delete to delete characters, with Ctrl to delete a word.
* Enter to submit a line.
* Ctrl-C to exit.

Usage
----------------
Before you include this file in C or C++ file,
define "TOILETLINE_IMPLEMENTATION" to create the implementation.

* To initialize toiletline and put terminal into raw mode:
    int tl_init(void);

    Returns 1 on success.

* To read a line while in toiletline mode:
    int tl_readline(char *line_buffer, size_t size, const char *prompt);

    To support multi-byte characters and null at the end, size needs to be at least 2 or more.
    Submitted input will be written to *line_buffer as a null-terminated string.

    Returns:
    * -1 on internal error;
    * 0 on Enter;
    * 1 on Ctrl-C;
    * 2 when line read exceeded *line_buffer size.

* To read a character without waiting for Enter:
    int tl_getc(char *buffer, size_t size, const char *prompt)

* To exit:
    int tl_exit(void);

    Returns 1 on success.

* To get the amount of characters in a UTF-8 string:
    size_t tl_utf8_strlen(const char *s);

    Since number of bytes can be bigger than amount of characters,
    regular strlen will not work, and will only return the number of bytes before \0.

Examples
----------------
For an example program, take a look at example.c
