toiletline
----------------
Single-header library for immediate shell, meant to replace a small subset of
GNU Readline, and work on both Linux and Windows.

All features like echoing characters and hadling keys are implemented from
scratch in raw mode.

Any help finding bugs is appreciated.


Current features
----------------
* UTF-8 support;
* In-memory history;
* CTRL to move/erase a word;
* End/Home to jump to end/beginning.


Documentation
----------------
Before you include this file in C or C++ file, define
"TOILETLINE_IMPLEMENTATION" to create the implementation.

If you want to use this library in C++ or other languages, you will need to
make a .c file which creates implementation and includes the library. Compile
it to object file ('-c' flag in gcc/clang) and link your code against it.


Definitions
--------
Int functions can return error codes. They are always above 0, and defined as:
* TL_ERROR;
* TL_ERROR_SIZE;
* TL_ERROR_ALLOC.

Last pressed control sequence will be stored in 'tl_last_control' as int. Note
that last control sequence for tl_readline() can only be Enter or Interrupt. 

Related values:

Bit masks:
* TL_MASK_KEY;
* TL_MASK_MOD.

Possible mod values:
* TL_MOD_CTRL;
* TL_MOD_SHIFT;
* TL_MOD_ALT.

Possible key values:
* TL_KEY_CHAR;
* TL_KEY_UNKN;
* TL_KEY_UP;
* TL_KEY_DOWN;
* TL_KEY_RIGHT;
* TL_KEY_LEFT;
* TL_KEY_END;
* TL_KEY_HOME;
* TL_KEY_ENTER;
* TL_KEY_BACKSPACE;
* TL_KEY_DELETE;
* TL_KEY_TAB;
* TL_KEY_INTERRUPT.

They can be tested with bitwise AND (&).


int tl_init(void);
--------
Initialize toiletline and put terminal into raw mode.
Returns TL_SUCCESS.


int tl_readline(char *line_buffer, size_t size, const char *prompt);
--------
Read a line while in raw mode.

To support multi-byte characters and null at the end, size needs to be at least
2 or more. Submitted input will be written to *line_buffer as a null-terminated
string.

Beware of characters like '\t' (Tab) and such, as they may break cursor
position. Althrough they are considered as a single character, they occupy more
than one space.

All control sequences except Enter and Interrupt will be handled internally.

Returns:
* TL_PRESSED_ENTER on Enter;
* TL_PRESSED_CTRLC on Ctrl-C;


int tl_getc(char *char_buffer, size_t size, const char *prompt);
--------
Read a character without waiting for Enter.

Returns:
* TL_SUCCESS on a character;
* TL_PRESSED_ENTER on Enter;
* TL_PRESSED_CTRLC on Ctrl-C;
* TL_PRESSED_CONTROL_SEQUENCE on other control sequences.


int tl_exit(void);
--------
Exit and deallocate memory.
Returns TL_SUCCESS.


size_t tl_utf8_strlen(const char *utf8_str);
--------
Get the amount of characters in a UTF-8 string.

Since number of bytes can be bigger than amount of characters, regular strlen
will not work, and will only return the number of bytes before \0.


Examples
----------------
For example usage, take a look at example.c and example_getc.c
